# Transaction

## 트랜잭션이란?

: 데이터베이스의 상태를 변화시키기위해 수행하는 작업의 단위

- 데이터베이스에 연결을 요청하여 커넥션을 맺게되면 데이터베이스는 세션을 생성한다. 추후 해당 커넥션을 통한 모든 요청은 세션을 통해 실행된다. 즉, 하나의 커넥션 당 하나의 세션이 생성된다!
- 특징 ( ACID )
    - 원자성 (Atomicity)
        - 트랜잭션이 DB에 모두 반영되거나, 혹은 모두 반영되지 않는다.
    - 일관성 (Consistency)
        - 트랜잭션의 작업 처리 결과는 항상 동일하다.
    - 독립성 (Isolcation)
        - 둘 이상의 트랜잭션에 동시에 실행될 때, 서로 다른 트랜잭션의 연산에 영향을 주지 않는다.
    - 지속성 (Durability)
        - 트랜잭션의 완료 후 결과는 영구적으로 반영된다.
- TPS ( Transaction Per Second )

  : 초당 트랜잭션 수

    - 1초에 실행되고있는 트랜잭션의 수
    - 얼마나 실행되고 있는지, 에러율은 얼마인지 등 애플리케이션 성능을 측정할 때 중요한 지표로 쓰인다.
- commit
    - 트랜잭션이 수행될 때 원본 DB에 바로 수행하는 것이 아니라 변경 부분을 복사하여 메모리에서 진행하고, 트랜잭션이 정상적으로 수행되면 그때 원본 DB에 적용한다. 이를 commit이라고 한다!
    - 즉, 하나의 트랜잭션이 성공적으로 끝났음을 알려주는 연산!
- rollback
    - 트랜잭션 과정에서 처리가 비정상적으로 종료된 경우 메모리에서 하고있던 작업을 commit 하지 않고 메모리에서 삭제해버린다. 따라서 원본 DB가 트랜잭션 처리 전과 동일한 상태가 된다. 이를
      rollback이라고 한다!

## 트랜잭션 격리 수준

- Dirty Read, Non-Repeatable Read, PantomRead 지원 여부에 따라 4가지 수준으로 나뉜다.
    - Dirty Read : commit 안해도 읽기 가능
    - Non-Repeatable Read :  한 트랜잭션 안에서 특정 row를 두번 이상 읽을 때, 두 번의 쿼리가 결과가 다르게 나타나는 현상 → 다른 작업을 수행하고있는 트랜잭션에서 데이터가 수정 된 것!
    - PantomRead : 한 트랜잭션 안에서 일정범위의 레코드를 두번 이상 읽을 때, 첫 번재 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상 → 다른 작업을 수행하고있는 트랜잭션에서 생성,
      삭제한 데이터가 보이는 것!
- READ UNCOMMITED ( 레벨1 )
    - 각 트랜잭션에서의 변경이 다른 트랜잭션에게도 모두 공개
    - Dirty Read, Non-Repeatable Read, PantomRead 발생
    - 성능은 제일 좋으나 정합성에 문제가 많아 잘 사용되지 않는다.
- READ COMMITED ( 레벨2 )
    - commit 완료된 데이터만 다른 트랜잭션에서 조회 가능
    - Non-Repeatable Read, PantomRead 발생
    - 오라클, 스프링의 기본 설정
- REPEATABLE READ ( 레벨3 )
    - 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 커밋된 것만 조회 가능
    - PantomRead 발생
    - 그렇다면 왜 MySQL의 InnoDB는 REPEATABLE READ을 기본값으로 채택했는가?
        - MySQL의 InnoDB는 트랜잭션이 시작되어 처음으로 select하는 순간 undo log를 생성하여 그 시점의 데이터를 저장하고, 조회 시 실제 데이터베이스가 아니라 undo log를 읽음으로써
          REPEATABLE READ를 보장한다. ( 이를 `MVCC` 라고 한다! )
        - 따라서 대부분의 Phantom Read 또한 undo log를 읽음으로써 해소된다.
        - 다만,  `select … for update`, `select … in share mode`, `update 이후 select`와 같이 실제 데이터베이스를 조회하도록 강제된 메서드를 이용하면
          발생할 수 있다.
- SERIALIZABLE ( 레벨4 )
    - select에까지 모두 공유 잠금을 설정함으로써 엄격하게 격리를 유지한다.
    - MySQL에서 설정을 이 값으로 바꾸면 모든 select 구문을 `SELECT ... FOR SHARE`으로 변경하여 실행한다.
    - 성능저하가 발생할 수 있다.
- redo
    - 과거의 모든 상태가 다 기록하여 처음부터 다시 실행함으로써 복구
- undo
    - REPEATABLE READ에서의 데이터 일관성 보장, rollback을 위해서 이용
    - 돌아가려는 시점의 데이터로만 복구! 그 과정은 알 필요 X
    - 트랜잭션 하나당 하나의 undo log를 가지고 있다.
    - undo log
        - rollback, repeatable read에서 트랜잭션 실행 이전의 데이터를 조회하기 위해 데이터를 저장해놓는 영역
        - image 형태로 데이터를 저장하고, 이는 circular queue 형태로 저장되어있다.
        - 하나의 저장된 영역을 여러 트랜잭션이 사용할 수 있다.

## 트랜잭션 전파 옵션

: 트랜잭션 동작 도중 다른 트랜잭션을 호출할 때 어떻게 호출할지를 선택

- REQUIRED ( 기본값 )
    - 부모 트랜잭션 내에서 실행, 없다면 새로운 트랜잭션 생성
    - 자식 트랜잭션의 커밋, 롤백이 부모 트랜잭션에도 영향이 간다.
- REQUIRED_NEW
    - 부모 트랜잭션 무시. 무조건 새로운 트랜잭션 생성!
    - 이미 진행중인 트랜잭션이 있다면 보류
    - 따라서 자식 트랜잭션이 롤백되어도 부모트랜잭션에 영향이 가지 않는다.
    - 다만! 자바에서는 예외가 발생하면 어딘가에서 꼭 처리를 해줘야한다. 자식 트랜잭션에서 예외가 발생하고 이 예외가 부모트랜잭션에까지 throws 된다면 부모트랜잭션도 롤백된다.
    - 따라서 자바에서 REQUIRED_NEW을 통해 부모와 자식을 완전히 분리하고싶다면 자식 트랜잭션에서 try-catch를 꼭 해줘야한다!
- SUPPORTS
    - 이미 시작된 트랜잭션이 있다면 참여, 없다면 트랜잭션 없이 진행
- MANDATORY
    - 이미 시작된 트랜잭션이 있다면 참여, 없다면 예외 발생
    - 독립적으로 트랜잭션을 진행하면 안되는 경우 사용
- NESTED
    - 이미 진행중인 트랜잭션이 있다면 중첩으로! 해당 트랜잭션 안에 다시 트랜잭션을 만듦
    - 중첩된 트랜잭션의 커밋, 롤백은 부모 트랜잭션에게 아무 영향이 없다.
    - 부모 트랜잭션이 롤백되면 중첩된 트랜잭션도 롤백된다.
    - ex) 로그를 저장해야하는 경우

  → 로그 저장작업이 실패한다고 부모 트랜잭션까지 롤백되면 절대 안되지만, 부모 트랜잭션이 롤백되면 로그작업도 롤백되어야 한다.

    - Spring은 JDBC의 save point 기능을 이용하여 경계를 설정한다.
    - JPA에서 중첩 트랜잭션을 이용할 경우 JpaDialect does not support savepoints 예외가 발생한다.
- NOT_SUPPORTED
    - 트랜잭션 자체를 무시하여 트랜잭션 없이 진행
    - 이미 진행중인 트랜잭션이 있다면 보류
    - 임의의 메소드 하나에만 트랜잭션을 적용하지 않는 경우 사용
- NEVER
    - 트랜잭션을 사용하지 않도록 강제
    - 이미 진행중인 트랜잭션이 있다면 예외 발생

## 논리 트랜잭션 vs 물리 트랜잭션

- 하나의 트랜잭션이 수행중이고, 아직 끝나지 않았는데 또 다른 트랜잭션이 실행되는 경우가 있다. ( REQUIED를 사용했을 때 등 )
- 이때, 먼저 시작한 트랜잭션을 **외부 트랜잭션**, 그 뒤에 시작한 트랜잭션을 **내부 트랜잭션**이라고 한다.
- 이 경우 스프링에서는 논리 트랜잭션을 모아 하나의 물리 트랜잭션을 만든다.
- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.
- 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.
- `status.isNewTransaction()`로 외부/ 내부 트랜잭션을 구분할 수 있다.
